%{
 
#include <stdio.h>
#include <stdlib.h>
#define INT_LIT 10
#define IDENT 11
#define ADD_OP 21
#define SUB_OP 22
#define MULT_OP 23
#define DIV_OP 24
#define LEFT_PAREN 25
#define RIGHT_PAREN 26
#define UNKNOWN 99
 
%}

%option outfile="lexer_hw1.c" header-file="lexer_hw1.h"
%option warn nodefault
%option noyywrap
%option yylineno
 
LPAREN  "("
RPAREN  ")"
PLUS    "+"
MULT    "*"
SUB     "-"
DIV     "/"

NUMBER  [0-9]+
VAR     [a-zA-Z][a-zA-Z0-9]*
/* (I)nternal (F)ield (S)eparator */
IFS     [ \r\n\t]*

%%
 
{IFS}     { /* Skip blanks. */ }
{VAR}     { printf("TOKEN: %d, LEXEME: %s\n", IDENT, yytext); return IDENT; } 
{NUMBER}  { printf("TOKEN: %d, LEXEME: %s\n", INT_LIT, yytext); return INT_LIT; }

{SUB}     { printf("TOKEN: %d, LEXEME: %s\n", SUB_OP,yytext); return SUB_OP; } 
{DIV}     { printf("TOKEN: %d, LEXEME: %s\n", DIV_OP, yytext); return DIV_OP; } 
{MULT}    { printf("TOKEN: %d, LEXEME: %s\n", MULT_OP, yytext); return MULT_OP; } 
{PLUS}    { printf("TOKEN: %d, LEXEME: %s\n", ADD_OP, yytext); return ADD_OP; } 
{LPAREN}  { printf("TOKEN: %d, LEXEME: %s\n", LEFT_PAREN, yytext); return LEFT_PAREN; } 
{RPAREN}  { printf("TOKEN: %d, LEXEME: %s\n", RIGHT_PAREN, yytext); return RIGHT_PAREN; } 
<<EOF>>   { printf("TOKEN: %d, LEXEME: EOF\n", EOF); return EOF; }
.         { fprintf(stderr, "ERROR: UNKNOWN LEXEME %s, on line %d\n", yytext, yylineno); }
 
%%

int nextToken = -1;

void expr();
void term();
void factor();
int yyerror(const char*);

/* 
 * Function expr 
 * Parses strings in the language
 * generated by the rule:
 * <expr> â†’ <term> {(+ | -) <term>}
 */
void expr() {

	printf("Entering <expr>\n");

	/* Parse the first term */
	term(); 

	/* As long as the next token is + or -
	, call lex to get the next token and 
	parse the next term */
	while (nextToken == ADD_OP 
		|| nextToken == SUB_OP) {

		nextToken = yylex();
		term();  
	}

	printf("Exit <expr>\n");
}

/* 
 * Parses strings in the language 
 * generated by the rule:
 * <term> -> <factor> {(* | /) <factor>}
 */
void term() {

	printf("Entering <term>\n");

	/* Parse the first factor */
	factor();

	/* As long as the next token is * or /,
	next token and parse the next factor */
	while (nextToken == MULT_OP 
		|| nextToken == DIV_OP) {

		nextToken = yylex();
		factor();
	}

	printf("Exit <term>\n");
}

/* Function factor
 * Parses strings in the language 
 * generated by the rule: 
 * <factor> -> id | int_constant |( <expr>) 
 */
void factor() {

	printf("Entering <factor>\n");

	/* Determine which RHS */
	if (nextToken == IDENT || nextToken == INT_LIT) {

		/* For the RHS id or int, just call lex */
		nextToken = yylex();
		while (nextToken == IDENT 
			|| nextToken == INT_LIT) {

			yyerror("a variable or an integer follows a variable or an integer");
			nextToken = yylex();
		}
	}
	/* If the RHS is (<expr>)
	 * call lex to pass over
	 * the left parenthesis, call expr, 
	 * and check for the right parenthesis 
	 */
	else if (nextToken == LEFT_PAREN) {

		nextToken = yylex();
		expr();

		if (nextToken == RIGHT_PAREN) {

			nextToken = yylex();
		}
		else {

			yyerror("unbalanced parens");
		}
	}
	else {
		
		yyerror("operator follows another operator");
		nextToken = yylex();
		while (nextToken == ADD_OP 
			|| nextToken == SUB_OP
			|| nextToken == MULT_OP
			|| nextToken == DIV_OP) {
			
			yyerror("operator follows another operator");
			nextToken = yylex();
		}
	}

	printf("Exit <factor>\n");
}

int main(int argc, char** argv) {

	++argv, --argc;  /* skip over program name */

	if (argc > 0) {

		yyin = fopen(argv[0], "r");
	}
	else {

		yyin = stdin;
	}

	nextToken = yylex();
	expr();
	return 0;
}

int yyerror(const char *msg) {

    fprintf(stderr, "ERROR: %s, on line %d\n", msg, yylineno); 
	return 0;
}
